"""Git history processing and .history directory generation."""

import os
from pathlib import Path
from typing import Optional, List, Dict, Any
import git
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from rich.table import Table
from rich.panel import Panel

from .config import Config
from .ai import summarize_diff, generate_project_memory, CommitMemory, ProjectMemory

console = Console()


class CommitInfo:
    """Information about a processed commit."""
    
    def __init__(self, commit: git.Commit, diff_lines: int, diff_text: str):
        self.hash = commit.hexsha
        self.short_hash = commit.hexsha[:7]
        self.message = commit.summary
        self.author = commit.author.name
        self.date = commit.committed_datetime
        self.diff_lines = diff_lines
        self.diff_text = diff_text


def get_commit_diff(repo: git.Repo, commit: git.Commit) -> tuple[str, int]:
    """Get diff text and line count for a commit."""
    try:
        if commit.parents:
            # Compare with first parent
            diff_index = commit.diff(commit.parents[0], create_patch=True)
            diff_text = ""
            for diff_item in diff_index:
                if hasattr(diff_item, 'diff'):
                    if isinstance(diff_item.diff, bytes):
                        diff_text += diff_item.diff.decode('utf-8', errors='ignore')
                    else:
                        diff_text += str(diff_item.diff)
        else:
            # Initial commit - diff against empty tree
            empty_tree = "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
            try:
                diff_output = repo.git.diff(empty_tree, commit.hexsha)
                diff_text = diff_output
            except git.exc.GitCommandError:
                diff_text = f"Initial commit: {commit.summary}"
        
        diff_lines = len(diff_text.splitlines()) if diff_text else 0
        return diff_text, diff_lines
        
    except Exception as e:
        console.print(f"[yellow]Warning: Could not generate diff for commit {commit.hexsha[:7]}: {e}[/]")
        return "", 0


def create_history_structure(repo_path: Path) -> Path:
    """Create .history directory structure."""
    history_dir = repo_path / Config.history_dir_name
    history_dir.mkdir(exist_ok=True)
    return history_dir


def save_commit_files(history_dir: Path, commit_info: CommitInfo, model_provider: str, model: str) -> CommitMemory:
    """Save commit files to .history/<commit_hash>/ and return AI-generated memory."""
    commit_dir = history_dir / commit_info.hash
    commit_dir.mkdir(exist_ok=True)
    
    # Save diff.patch
    diff_file = commit_dir / "diff.patch"
    with open(diff_file, "w", encoding="utf-8") as f:
        f.write(commit_info.diff_text)
    
    # Generate AI-powered memory
    try:
        commit_memory = summarize_diff(
            diff_text=commit_info.diff_text,
            commit_message=commit_info.message,
            commit_hash=commit_info.hash,
            provider=model_provider,
            model=model
        )
        console.print(f"  [green]â†’ AI analysis complete for {commit_info.short_hash}[/]")
    except Exception as e:
        console.print(f"  [yellow]â†’ AI analysis failed for {commit_info.short_hash}: {e}[/]")
        # Create fallback memory
        from .ai import CommitChange
        commit_memory = CommitMemory(
            added=[CommitChange(
                description=f"Changes from commit: {commit_info.message}",
                files=[],
                impact="moderate" if commit_info.diff_lines > 50 else "minor"
            )],
            removed=[],
            changed=[],
            summary=commit_info.message,
            technical_details=f"Fallback memory - {commit_info.diff_lines} lines changed"
        )
    
    # Save AI-generated memory.md
    memory_file = commit_dir / "memory.md"
    memory_content = f"""# Commit Memory: {commit_info.short_hash}

**Commit:** {commit_info.hash}
**Author:** {commit_info.author}
**Date:** {commit_info.date.strftime('%Y-%m-%d %H:%M:%S')}
**Message:** {commit_info.message}

## Summary
{commit_memory.summary}

## Changes Analysis

### Added
{_format_changes(commit_memory.added)}

### Changed  
{_format_changes(commit_memory.changed)}

### Removed
{_format_changes(commit_memory.removed)}

## Technical Details
{commit_memory.technical_details if commit_memory.technical_details else 'No additional technical details.'}

---
*Generated by git-memory v{Config.version} using {model_provider}/{model}*
"""
    with open(memory_file, "w", encoding="utf-8") as f:
        f.write(memory_content)
    
    # Save placeholder structure.mmd (TODO: integrate with AI)
    structure_file = commit_dir / "structure.mmd"
    structure_content = f"""graph TD
    A["{commit_info.short_hash}"] --> B["Commit: {commit_info.message[:50]}..."]
    B --> C["{commit_info.diff_lines} lines changed"]
    
    %% Structure diagram generation coming soon
    %% Will be replaced with AI-generated structure diagrams
"""
    with open(structure_file, "w", encoding="utf-8") as f:
        f.write(structure_content)
    
    return commit_memory


def save_aggregated_files(history_dir: Path, processed_commits: List[CommitInfo], 
                         commit_memories: List[CommitMemory], model_provider: str, model: str) -> None:
    """Save aggregated history files with AI-generated content."""
    
    # Generate history.md (aggregated patches)
    history_content = "# Git History\n\n"
    history_content += f"Generated by git-memory v{Config.version}\n\n"
    
    for commit_info in processed_commits:
        history_content += f"## Commit {commit_info.short_hash}: {commit_info.message}\n\n"
        history_content += f"**Author:** {commit_info.author}\n"
        history_content += f"**Date:** {commit_info.date.strftime('%Y-%m-%d %H:%M:%S')}\n"
        history_content += f"**Lines changed:** {commit_info.diff_lines}\n\n"
        history_content += "```diff\n"
        history_content += commit_info.diff_text[:1000]  # Truncate for readability
        if len(commit_info.diff_text) > 1000:
            history_content += "\n... [truncated] ..."
        history_content += "\n```\n\n---\n\n"
    
    with open(history_dir / "history.md", "w", encoding="utf-8") as f:
        f.write(history_content)
    
    # Generate AI-powered aggregated memory
    try:
        project_memory = generate_project_memory(
            commit_memories=commit_memories,
            total_commits=len(processed_commits),
            provider=model_provider,
            model=model
        )
        console.print(f"[green]â†’ AI project analysis complete[/]")
    except Exception as e:
        console.print(f"[yellow]â†’ AI project analysis failed: {e}[/]")
        # Create fallback project memory
        project_memory = ProjectMemory(
            major_features=["Feature extraction failed - using fallback"],
            architecture_evolution=["Architecture analysis failed - using fallback"],
            key_decisions=["Decision analysis failed - using fallback"],
            current_state=f"Project with {len(processed_commits)} commits analyzed",
            next_steps=["Complete AI integration", "Improve error handling"]
        )
    
    # Generate memory.md (AI-powered aggregated memories)
    memory_content = f"""# Project Memory

Generated by git-memory v{Config.version} using {model_provider}/{model}

## Current State
{project_memory.current_state}

## Major Features Implemented
{_format_list_items(project_memory.major_features)}

## Architecture Evolution
{_format_list_items(project_memory.architecture_evolution)}

## Key Technical Decisions
{_format_list_items(project_memory.key_decisions)}

## Suggested Next Steps
{_format_list_items(project_memory.next_steps)}

## Commit Statistics
- **Total commits processed:** {len(processed_commits)}
- **Total lines changed:** {sum(c.diff_lines for c in processed_commits)}
- **AI memories generated:** {len(commit_memories)}

## Commit Timeline
{_format_commit_timeline(processed_commits, commit_memories)}
"""
    
    with open(history_dir / "memory.md", "w", encoding="utf-8") as f:
        f.write(memory_content)
    
    # Generate AI-enhanced structure diagram
    from .ai import generate_diagram
    structure_content = generate_diagram(commit_memories, project_memory)
    
    with open(history_dir / "structure.mmd", "w", encoding="utf-8") as f:
        f.write(structure_content)


def generate_history(
    repo_path: Path,
    model_provider: str,
    model: str,
    min_diff_lines: Optional[int] = None
) -> None:
    """Generate .history directory with commit-by-commit documentation."""
    
    try:
        # Open repository
        repo = git.Repo(repo_path)
        if repo.bare:
            raise ValueError(f"Repository at {repo_path} is bare")
        
        # Create .history structure
        history_dir = create_history_structure(repo_path)
        
        # Get all commits (oldest first)
        all_commits = list(repo.iter_commits('HEAD'))
        all_commits.reverse()
        
        console.print(f"\n[blue]Found {len(all_commits)} commits to analyze[/]")
        
        processed_commits: List[CommitInfo] = []
        skipped_count = 0
        
        # Process commits with progress bar
        commit_memories: List[CommitMemory] = []
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            
            task = progress.add_task("Processing commits...", total=len(all_commits))
            
            for i, commit in enumerate(all_commits):
                # Update progress description
                progress.update(task, description=f"Processing {commit.hexsha[:7]}: {commit.summary[:40]}...")
                
                # Get commit diff
                diff_text, diff_lines = get_commit_diff(repo, commit)
                
                # Apply min_diff_lines filter
                if min_diff_lines is not None and diff_lines < min_diff_lines:
                    console.print(f"  [yellow]â†’ Skipping {commit.hexsha[:7]}: {diff_lines} lines < {min_diff_lines} threshold[/]")
                    skipped_count += 1
                    progress.advance(task)
                    continue
                
                # Create commit info
                commit_info = CommitInfo(commit, diff_lines, diff_text)
                processed_commits.append(commit_info)
                
                # Save commit files and get AI memory
                commit_memory = save_commit_files(history_dir, commit_info, model_provider, model)
                commit_memories.append(commit_memory)
                
                console.print(f"  [green]âœ… Processed {commit_info.short_hash}: {commit_info.message} ({commit_info.diff_lines} lines)[/]")
                
                progress.advance(task)
        
        # Save aggregated files with AI-generated content
        save_aggregated_files(history_dir, processed_commits, commit_memories, model_provider, model)
        
        # Display summary
        display_summary(processed_commits, skipped_count, history_dir)
        
    except git.exc.InvalidGitRepositoryError:
        raise ValueError(f"{repo_path} is not a valid Git repository")
    except Exception as e:
        raise ValueError(f"Error processing repository: {e}")


def display_summary(processed_commits: List[CommitInfo], skipped_count: int, history_dir: Path) -> None:
    """Display processing summary."""
    
    table = Table(title="Processing Summary", show_header=True, header_style="bold blue")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="green")
    
    total_lines = sum(c.diff_lines for c in processed_commits)
    
    table.add_row("Commits processed", str(len(processed_commits)))
    table.add_row("Commits skipped", str(skipped_count))
    table.add_row("Total lines changed", str(total_lines))
    table.add_row("History directory", str(history_dir.relative_to(history_dir.parent)))
    
    console.print("\n")
    console.print(table)
    
    if processed_commits:
        console.print(f"\n[green]Generated files:[/]")
        console.print(f"  â€¢ [cyan]{history_dir}/memory.md[/] - Aggregated memory")
        console.print(f"  â€¢ [cyan]{history_dir}/history.md[/] - Aggregated patches")
        console.print(f"  â€¢ [cyan]{history_dir}/structure.mmd[/] - Structure diagram")
        console.print(f"  â€¢ [cyan]{len(processed_commits)} commit directories[/] - Individual commit data")


def _format_changes(changes) -> str:
    """Format list of CommitChange objects for markdown output."""
    if not changes:
        return "*No changes in this category*"
    
    formatted = []
    for change in changes:
        impact_emoji = {"minor": "ðŸ”¹", "moderate": "ðŸ”¸", "major": "ðŸ”¶"}
        emoji = impact_emoji.get(change.impact, "ðŸ”¹")
        
        line = f"{emoji} **{change.description}**"
        if change.files:
            line += f" ({', '.join(change.files[:3])}{'...' if len(change.files) > 3 else ''})"
        line += f" *[{change.impact} impact]*"
        formatted.append(line)
    
    return "\n".join(formatted)


def _format_list_items(items: List[str]) -> str:
    """Format list of strings as markdown bullet points."""
    if not items:
        return "*No items available*"
    
    return "\n".join(f"- {item}" for item in items)


def _format_commit_timeline(processed_commits: List[CommitInfo], commit_memories: List[CommitMemory]) -> str:
    """Format commit timeline with AI-generated summaries."""
    if not processed_commits:
        return "*No commits processed*"
    
    timeline = []
    for i, commit_info in enumerate(processed_commits):
        line = f"- **{commit_info.short_hash}** ({commit_info.date.strftime('%Y-%m-%d')}): {commit_info.message}"
        
        # Add AI summary if available
        if i < len(commit_memories):
            memory = commit_memories[i]
            changes_count = len(memory.added) + len(memory.changed) + len(memory.removed)
            if changes_count > 0:
                line += f" *[{changes_count} changes tracked]*"
        
        line += f" ({commit_info.diff_lines} lines)"
        timeline.append(line)
    
    return "\n".join(timeline)